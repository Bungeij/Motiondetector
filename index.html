<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Nacht‑Wächter – Fahrzeug‑Annäherung (Beta)</title>
<style>
  :root{
    --bg:#0b0e12;
    --panel:#12161c;
    --text:#d8dee9;
    --muted:#7a8899;
    --accent:#4fb3ff;
    --danger:#ff5555;
    --ok:#28d07e;
    --warn:#ffd166;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;}
  .wrap{display:flex;flex-direction:row;gap:16px;padding:14px;box-sizing:border-box; height:100%;}
  .left, .right{display:flex;flex-direction:column;gap:12px;}
  .left{flex:3;min-width:60vw;}
  .right{flex:2;}
  .panel{background:var(--panel);border:1px solid #1b2230;border-radius:14px;padding:12px;box-shadow:0 0 0 1px #0e131a inset;}
  h1{font-size:18px;margin:0 0 10px 0;color:#c6d4f0;font-weight:600;letter-spacing:.2px;}
  video{width:100%;height:calc(100vh - 160px);object-fit:cover;border-radius:12px;background:#000;}
  .bar{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
  button, select, input[type="range"]{background:#0f141b;color:var(--text);border:1px solid #2a3444;border-radius:10px;padding:10px 12px;font-size:14px}
  button{cursor:pointer;transition:transform .06s ease, background .2s ease}
  button:active{transform:scale(.98)}
  .primary{background:#13304a;border-color:#245f8a}
  .danger{background:#3b1111;border-color:#6b1d1d;color:#ffdada}
  .ok{background:#0f2a1e;border-color:#214e39;color:#d6ffe8}
  .muted{opacity:.85}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .meter{height:10px;background:#0d1218;border:1px solid #2a3444;border-radius:999px;position:relative;overflow:hidden}
  .meter>span{position:absolute;left:0;top:0;bottom:0;width:0;background:linear-gradient(90deg, var(--accent), #67ffd1)}
  .readout{font-variant-numeric:tabular-nums;font-size:13px;color:var(--muted)}
  canvas{display:none}
  .hint{font-size:12px;color:var(--muted);line-height:1.4}
  .status{padding:10px;border-radius:10px;background:#0d141b;border:1px dashed #2a3444}
  .status strong{color:#fff}
  .pill{padding:6px 8px;border-radius:999px;border:1px solid #2a3444;background:#0f141b;color:#c7d7ee;font-size:12px}
  .footer{font-size:11px;color:#7f8ca3;text-align:center;opacity:.85;padding-top:6px}
  @media (orientation:portrait) {
     .wrap{flex-direction:column}
     video{height:45vh}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="left">
    <div class="panel">
      <div class="bar" style="justify-content:space-between;align-items:center">
        <div class="bar" style="gap:6px">
          <span class="pill" id="camLabel">Kamera: –</span>
          <span class="pill" id="fpsLabel">0 FPS</span>
          <span class="pill" id="alarmLabel">Alarm: AUS</span>
        </div>
        <div class="bar">
          <button id="startBtn" class="primary">Kamera starten</button>
          <button id="toggleCamBtn" class="muted">Front/Back</button>
          <button id="resetBtn" class="ok">Reset</button>
          <button id="alarmTestBtn">Alarm‑Test</button>
        </div>
      </div>
    </div>
    <video id="video" playsinline autoplay muted></video>
  </div>

  <div class="right">
    <div class="panel">
      <h1>Erkennung & Einstellungen</h1>
      <div class="grid">
        <div>
          <div class="readout">Bewegung gesamt: <span id="motionPctTxt">0%</span></div>
          <div class="meter"><span id="motionPct"></span></div>
        </div>
        <div>
          <div class="readout">Zentrum‑Dominanz: <span id="centerDomTxt">0%</span></div>
          <div class="meter"><span id="centerDom"></span></div>
        </div>
      </div>
      <div style="height:8px"></div>
      <div class="grid">
        <label class="bar">Empfindlichkeit
          <input id="sens" type="range" min="10" max="90" value="55" />
        </label>
        <label class="bar">Mindest‑Bewegung
          <input id="minMotion" type="range" min="2" max="25" value="6" />
        </label>
      </div>
      <div class="hint">
        Ziel: Annähernde Fahrzeuge erzeugen zunehmende Bewegung im mittleren Sichtfeld
        und einen Anstieg der Helligkeit. Heuristische Erkennung (kein ML): 
        <ul>
          <li>starker Frame‑Unterschied</li>
          <li>Bewegung im zentralen Bereich dominiert</li>
          <li>Trend steigt über mehrere Frames</li>
        </ul>
      </div>
      <div class="status" id="statusBox">Status: <strong>Bereit</strong></div>
      <div class="footer">Optimiert für Querformat • dunkles UI • Funktioniert am besten über HTTPS in Safari/Chrome (iOS 15+). Ton benötigt einmalige Nutzer‑Interaktion.</div>
    </div>
  </div>
</div>

<canvas id="work" width="640" height="360"></canvas>
<script>
const video = document.getElementById('video');
const work = document.getElementById('work');
const wctx = work.getContext('2d', { willReadFrequently: true });

const startBtn = document.getElementById('startBtn');
const toggleCamBtn = document.getElementById('toggleCamBtn');
const resetBtn = document.getElementById('resetBtn');
const alarmTestBtn = document.getElementById('alarmTestBtn');

const motionPctBar = document.getElementById('motionPct');
const centerDomBar = document.getElementById('centerDom');
const motionPctTxt = document.getElementById('motionPctTxt');
const centerDomTxt = document.getElementById('centerDomTxt');

const camLabel = document.getElementById('camLabel');
const fpsLabel = document.getElementById('fpsLabel');
const alarmLabel = document.getElementById('alarmLabel');
const statusBox = document.getElementById('statusBox');

const sens = document.getElementById('sens');
const minMotion = document.getElementById('minMotion');

let usingBack = true;
let mediaStream = null;
let prev = null;
let lastTimes = [];
let trendBuffer = [];
let alarmOn = false;
let audio = null;
let audioReady = false;

function setStatus(text){
  statusBox.innerHTML = 'Status: <strong>'+text+'</strong>';
}

async function startAudio() {
  if(audioReady) return;
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const master = ctx.createGain(); master.gain.value = 0.0; master.connect(ctx.destination);
  // Create an oscillator for the alarm tone; enable when triggered
  const osc = ctx.createOscillator(); osc.type = 'sawtooth'; osc.frequency.value = 880;
  const gain = ctx.createGain(); gain.gain.value = 0.0;
  osc.connect(gain).connect(master);
  osc.start();
  audio = {ctx, master, gain, osc};
  audioReady = true;
}

function setAlarm(state){
  alarmOn = state;
  alarmLabel.textContent = 'Alarm: ' + (alarmOn ? 'AN' : 'AUS');
  if(!audioReady) return;
  if(alarmOn){
    // pulsing siren
    audio.master.gain.cancelScheduledValues(0);
    audio.gain.gain.cancelScheduledValues(0);
    audio.master.gain.linearRampToValueAtTime(0.9, audio.ctx.currentTime + 0.05);
    let t = audio.ctx.currentTime;
    audio.gain.gain.setValueAtTime(0.0001, t);
    for(let i=0;i<6;i++){
      audio.gain.gain.exponentialRampToValueAtTime(0.8, t+=0.12);
      audio.gain.gain.exponentialRampToValueAtTime(0.001, t+=0.12);
    }
  } else {
    audio.master.gain.linearRampToValueAtTime(0.0, audio.ctx.currentTime + 0.1);
  }
}

async function startCamera(){
  try{
    if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); }
    const constraints = {
      audio:false,
      video:{
        facingMode: usingBack ? { exact:'environment' } : 'user',
        width: { ideal: 1280 }, height: { ideal: 720 }
      }
    };
    mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
    const settings = mediaStream.getVideoTracks()[0].getSettings?.() || {};
    camLabel.textContent = 'Kamera: ' + (settings.facingMode || (usingBack?'environment':'user'));
    video.srcObject = mediaStream;
    await video.play();
    work.width = 640;
    work.height = Math.floor(640 * (video.videoHeight || 360) / (video.videoWidth || 640));
    prev = null;
    setStatus('Kamera läuft');
    loop();
  }catch(e){
    console.error(e);
    setStatus('Fehler: ' + e.message);
  }
}

function diffFrame(){
  // draw smaller to reduce workload
  wctx.drawImage(video, 0, 0, work.width, work.height);
  const curr = wctx.getImageData(0, 0, work.width, work.height);
  if(!prev){ prev = curr; return {motion:0, center:0, brightness:0}; }
  const p = prev.data, c = curr.data;
  let motion = 0, center = 0, brightness = 0;
  const cx0 = Math.floor(work.width*0.28), cx1 = Math.floor(work.width*0.72);
  const cy0 = Math.floor(work.height*0.28), cy1 = Math.floor(work.height*0.72);
  for(let i=0;i<c.length;i+=4){
    const y = Math.floor((i/4)/work.width);
    const x = (i/4)%work.width;
    const pr = p[i], pg = p[i+1], pb = p[i+2];
    const cr = c[i], cg = c[i+1], cb = c[i+2];
    const pd = (pr+pg+pb)/3, cd = (cr+cg+cb)/3;
    const d = Math.abs(cd - pd); // frame difference
    if (d > 20) { // threshold
      motion++;
      if(x>cx0 && x<cx1 && y>cy0 && y<cy1) center++;
    }
    brightness += cd;
  }
  prev = curr;
  const total = work.width*work.height;
  return {
    motion: (motion/total)*100,
    center: total? (center/Math.max(1,motion))*100 : 0, // percent of motion that is in center
    brightness: brightness/(total*255)
  };
}

function updateMeters(motionPct, centerDom){
  const m = Math.min(100, motionPct);
  const c = Math.min(100, centerDom);
  motionPctBar.style.width = m + '%';
  centerDomBar.style.width = c + '%';
  motionPctTxt.textContent = m.toFixed(1) + '%';
  centerDomTxt.textContent = c.toFixed(1) + '%';
}

function shouldTrigger(motionPct, centerDom, brightness){
  // Heuristics
  const minM = parseInt(minMotion.value,10); // absolute min motion percent
  const sensitivity = parseInt(sens.value,10); // higher = more sensitive
  const centerWeight = (centerDom/100);
  const score = (motionPct * (0.6 + 0.6*centerWeight)) + (brightness*12);
  trendBuffer.push(score);
  if(trendBuffer.length>10) trendBuffer.shift();
  const trend = trendBuffer.length>5 ? (trendBuffer[trendBuffer.length-1] - trendBuffer[0]) : 0;
  // dynamic threshold from sensitivity
  const threshold = 12 + (40 - (sensitivity/90)*40); // 12..52
  return (motionPct > minM) && (centerDom>40) && (score+trend > threshold);
}

function loop(){
  const t0 = performance.now();
  const {motion, center, brightness} = diffFrame();
  updateMeters(motion, center);
  if(shouldTrigger(motion, center, brightness)){
    setStatus('Annäherung erkannt – ALARM!');
    setAlarm(true);
  }else if(!alarmOn){
    setStatus('Überwachung läuft …');
  }
  // FPS indicator
  const t1 = performance.now();
  lastTimes.push(t1); while(lastTimes.length>20) lastTimes.shift();
  if(lastTimes.length>1){
    const dt = (lastTimes[lastTimes.length-1]-lastTimes[0])/ (lastTimes.length-1);
    const fps = 1000/dt;
    fpsLabel.textContent = fps.toFixed(0)+' FPS';
  }
  requestAnimationFrame(loop);
}

// UI handlers
startBtn.addEventListener('click', async ()=>{
  await startAudio(); // prepare audio after user gesture
  await startCamera();
});

toggleCamBtn.addEventListener('click', async ()=>{
  usingBack = !usingBack;
  await startCamera();
});

resetBtn.addEventListener('click', ()=>{
  trendBuffer = [];
  setAlarm(false);
  setStatus('Zurückgesetzt');
});

alarmTestBtn.addEventListener('click', async ()=>{
  await startAudio();
  setAlarm(true);
  setTimeout(()=>setAlarm(false), 1200);
});

// Avoid blinding brightness
if ('wakeLock' in navigator && navigator.wakeLock.request) {
  // best effort: keep screen awake
  navigator.wakeLock.request('screen').catch(()=>{});
}
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden) setAlarm(false);
});
</script>
</body>
</html>